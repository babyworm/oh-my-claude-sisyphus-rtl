// {{PROJECT_NAME}} - SystemVerilog Module
// Generated by oh-my-claude-rtl
//
// Description:
//   {{DESCRIPTION}}
//
// Parameters:
//   DATA_WIDTH - Width of data bus (default: 32)
//
// Ports:
//   clk       - Clock input
//   rst_n     - Active-low reset
//   valid_in  - Input data valid signal
//   data_in   - Input data
//   ready_out - Ready to accept data
//   valid_out - Output data valid signal
//   data_out  - Output data
//   ready_in  - Downstream ready signal

`timescale 1ns / 1ps

module {{MODULE_NAME}} #(
    parameter int DATA_WIDTH = 32
) (
    input  logic                  clk,
    input  logic                  rst_n,

    // Input interface
    input  logic                  valid_in,
    input  logic [DATA_WIDTH-1:0] data_in,
    output logic                  ready_out,

    // Output interface
    output logic                  valid_out,
    output logic [DATA_WIDTH-1:0] data_out,
    input  logic                  ready_in
);

    // Internal signals
    logic [DATA_WIDTH-1:0] data_reg;
    logic                  valid_reg;

    // State machine (if needed)
    typedef enum logic [1:0] {
        IDLE  = 2'b00,
        BUSY  = 2'b01,
        DONE  = 2'b10
    } state_t;

    state_t state, state_next;

    //----------------------------------------------------------------------
    // Sequential Logic
    //----------------------------------------------------------------------

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            state      <= IDLE;
            data_reg   <= '0;
            valid_reg  <= 1'b0;
        end else begin
            state      <= state_next;

            // Data path
            if (valid_in && ready_out) begin
                data_reg  <= data_in;
                valid_reg <= 1'b1;
            end else if (valid_out && ready_in) begin
                valid_reg <= 1'b0;
            end
        end
    end

    //----------------------------------------------------------------------
    // Combinational Logic
    //----------------------------------------------------------------------

    always_comb begin
        // Default values
        state_next = state;
        ready_out  = 1'b0;

        case (state)
            IDLE: begin
                ready_out = 1'b1;
                if (valid_in) begin
                    state_next = BUSY;
                end
            end

            BUSY: begin
                if (ready_in) begin
                    state_next = IDLE;
                end
            end

            default: begin
                state_next = IDLE;
            end
        endcase
    end

    //----------------------------------------------------------------------
    // Output Assignment
    //----------------------------------------------------------------------

    assign valid_out = valid_reg;
    assign data_out  = data_reg;

    //----------------------------------------------------------------------
    // Assertions (for simulation)
    //----------------------------------------------------------------------

    `ifndef SYNTHESIS
    // Check for X/Z on critical signals
    property no_x_on_valid;
        @(posedge clk) disable iff (!rst_n)
        !$isunknown(valid_in);
    endproperty
    assert property (no_x_on_valid) else $error("X/Z detected on valid_in");

    // Check handshake protocol
    property valid_stable;
        @(posedge clk) disable iff (!rst_n)
        (valid_out && !ready_in) |=> $stable(data_out);
    endproperty
    assert property (valid_stable) else $error("data_out changed while valid_out && !ready_in");
    `endif

endmodule
